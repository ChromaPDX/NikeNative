@interface

struct LightProperties {
    vec3 position;
    vec3 ambient;
    vec3 color;
    
    vec3 halfVector;
    vec3 coneDirection;
    
    float spotCosCutoff;
    float spotExponent;
    float constantAttenuation;
    float linearAttenuation;
    float quadraticAttenuation;
    
    bool isEnabled;
    bool isLocal;
    bool isSpot;
};

@interface

@vertex

@vertex

@frag

//
// LIGHT PROGRAM
//

vec3 scatteredLight = vec3(0.0);
vec3 reflectedLight = vec3(0.0);

float Strength = 4.;
float Shininess = 10.;

vec3 halfVector;
vec3 lightDirection = u_light.position;
float attenuation = 1.0;
if (u_light.isLocal) {
    lightDirection = lightDirection - vec3(v_position);
    float lightDistance = length(lightDirection);
    lightDirection = lightDirection / lightDistance; // (normalize) ? ;
    attenuation = 1.0 / (u_light.constantAttenuation + (u_light.linearAttenuation * lightDistance) + (u_light.quadraticAttenuation * lightDistance * lightDistance));
    if (u_light.isSpot) {
        float spotCos = dot(lightDirection,-u_light.coneDirection);
        if (spotCos < u_light.spotCosCutoff) attenuation = 0.0;
        else attenuation *= pow(spotCos,u_light.spotExponent);
    }
    halfVector = normalize(lightDirection + u_eyeDirection);
}
else {
    halfVector = u_light.halfVector;
}

float diffuse = max(0.0, dot(v_normal, lightDirection));
float specular = max(0.0, dot(v_normal, halfVector));

//if (diffuse == 0.0) specular = 0.0;
specular = pow(specular, Shininess) * Strength * diffuse;
// Accumulate all the u_lightsâ€™ effects
scatteredLight += u_light.ambient * attenuation + u_light.color * diffuse * attenuation;
reflectedLight += u_light.color * specular * attenuation;

//vec3 rgb = min(Color.rgb * scatteredLight + reflectedLight, vec3(1.0));
//FragColor = vec4(rgb, Color.a);

lightColor = vec4(min(scatteredLight + reflectedLight,vec3(1.0)), 1.0);

@frag